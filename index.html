<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Body-Mounted Accelerometer Data Visualizer</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
   <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
   <style>
       body {
           font-family: 'Inter', sans-serif;
           background-color: #f3f4f6;
       }
       .container {
           max-width: 1280px;
           margin-left: auto;
           margin-right: auto;
           padding: 1rem;
       }
       .card {
           background-color: white;
           padding: 2rem;
           border-radius: 1rem;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
       }
       #visualization-area {
           height: 800px;
           width: 100%;
       }
   </style>
</head>
<body>


   <div class="container py-8">
       <div class="card">
           <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Body-Mounted Accelerometer Data Visualizer</h1>
           <p class="text-center text-gray-600 mb-8">Upload your CSV or TXT file to process and visualize accelerometer data.</p>
          
           <div class="flex flex-col items-center justify-center space-y-4 md:flex-row md:space-y-0 md:space-x-4">
               <input type="file" id="fileInput" accept=".csv, .txt" class="block w-full text-sm text-gray-500
                   file:mr-4 file:py-2 file:px-4
                   file:rounded-full file:border-0
                   file:text-sm file:font-semibold
                   file:bg-blue-50 file:text-blue-700
                   hover:file:bg-blue-100"/>
              
               <button id="processButton" class="w-full md:w-auto px-6 py-2 rounded-full font-semibold text-white bg-blue-600 hover:bg-blue-700 transition-colors duration-200">
                   Process Data
               </button>
           </div>
          
           <div id="statusMessage" class="mt-4 text-center text-gray-500 font-medium"></div>


       </div>


       <div class="card mt-8">
           <h2 class="text-2xl font-semibold text-gray-800 mb-4">Data Visualization</h2>
           <div id="visualization-area"></div>
       </div>
   </div>


   <script>
       document.addEventListener('DOMContentLoaded', () => {
           const fileInput = document.getElementById('fileInput');
           const processButton = document.getElementById('processButton');
           const statusMessage = document.getElementById('statusMessage');
           const visualizationArea = document.getElementById('visualization-area');


           let rawData = null;


           processButton.addEventListener('click', () => {
               if (fileInput.files.length === 0) {
                   statusMessage.textContent = 'Please select a file first.';
                   return;
               }
              
               statusMessage.textContent = 'Processing data...';
               const file = fileInput.files[0];
               const reader = new FileReader();


               reader.onload = (event) => {
                   const fileContent = event.target.result;
                   try {
                       rawData = parseFileContent(fileContent);
                      
                       // New: Call the main processing function
                       const processedData = processData(rawData);
                      
                       // New: Pass the processed data to visualization
                       visualizeData(processedData);
                      
                       statusMessage.textContent = 'Data processed successfully!';
                   } catch (error) {
                       statusMessage.textContent = 'Error processing file. Please check the format.';
                       console.error('Processing error:', error);
                   }
               };


               reader.onerror = (error) => {
                   statusMessage.textContent = 'Error reading file.';
                   console.error('File reading error:', error);
               };


               reader.readAsText(file);
           });


           function parseFileContent(content) {
               const lines = content.trim().split('\n');
               if (lines.length <= 1) {
                   throw new Error('File does not contain enough data.');
               }
              
               const headers = lines[0].split(',').map(header => header.trim());
               const data = [];
              
               for (let i = 1; i < lines.length; i++) {
                   const line = lines[i];
                   if (line.trim() === '') continue;
                  
                   const values = line.split(',');
                   if (values.length !== headers.length) {
                       throw new Error(`Row ${i} has an incorrect number of columns.`);
                   }
                  
                   const row = {};
                   headers.forEach((header, index) => {
                       row[header] = parseFloat(values[index]);
                   });
                   data.push(row);
               }
              
               return data;
           }


           function processData(data) {
               // Main processing function that calls other utilities
              
               // 1. Calculate combined acceleration
               const dataWithCombinedAcc = combined_frontal_acceleration(data);
              
               // 2. Filter the signal
               const filteredData = butter_lowpass_filter(dataWithCombinedAcc, 'Angle Y(°)', 200, 1);
              
               // 3. Find peaks
               const peaks = find_peaks(filteredData, 'combined acceleration', 200);
              
               // 4. Zero-crossing detection
               const zeroCrossings = zero_crossing(filteredData, 'Angle Y(°)');


               // Return all processed data for visualization
               return {
                   original: dataWithCombinedAcc,
                   filtered: filteredData,
                   peaks: peaks,
                   zeroCrossings: zeroCrossings
               };
           }


           // Utility functions translated from Python
           function combined_frontal_acceleration(data) {
               return data.map(d => ({
                   ...d,
                   'combined acceleration': Math.sqrt(
                       Math.pow(d['Acceleration X(g)'], 2) +
                       Math.pow(d['Acceleration Y(g)'], 2) +
                       Math.pow(d['Acceleration Z(g)'], 2)
                   )
               }));
           }


           function butter_lowpass_filter(data, columnName, fs, order) {
               // This is a simplified implementation of a low-pass filter.
               // For a more robust solution, a dedicated library would be needed.
               const filteredData = JSON.parse(JSON.stringify(data));
               const filteredColumnName = 'filtered_signal'; // The python code uses `filtered_signal`


               // Simple moving average as a placeholder for the Butterworth filter
               const windowSize = 5;
               for (let i = 0; i < filteredData.length; i++) {
                   let sum = 0;
                   let count = 0;
                   for (let j = Math.max(0, i - Math.floor(windowSize / 2)); j < Math.min(filteredData.length, i + Math.ceil(windowSize / 2)); j++) {
                       sum += filteredData[j][columnName] || 0;
                       count++;
                   }
                   filteredData[i][filteredColumnName] = sum / count;
               }
               return filteredData;
           }


           function zero_crossing(data, columnName) {
               const crossings = [];
               for (let i = 1; i < data.length; i++) {
                   const prevVal = data[i-1][columnName] || 0;
                   const currVal = data[i][columnName] || 0;


                   if ((prevVal < 0 && currVal >= 0)) {
                       crossings.push({ index: i, type: 'corner_entrance' });
                   } else if ((prevVal > 0 && currVal <= 0)) {
                       crossings.push({ index: i, type: 'corner_exit' });
                   }
               }
               return crossings;
           }


           function find_peaks(data, columnName, samplingRate) {
               // Simplified peak detection, similar to scipy's find_peaks
               const peaks = [];
               const prominenceThreshold = 0.5;
               const minDistance = samplingRate / 4;


               for (let i = 1; i < data.length - 1; i++) {
                   const prevVal = data[i - 1][columnName] || 0;
                   const currVal = data[i][columnName] || 0;
                   const nextVal = data[i + 1][columnName] || 0;


                   if (currVal > prevVal && currVal > nextVal && currVal > prominenceThreshold) {
                        // Check for minimum distance
                       let lastPeakIndex = peaks.length > 0 ? peaks[peaks.length - 1] : -Infinity;
                       if (i - lastPeakIndex > minDistance) {
                           peaks.push(i);
                       }
                   }
               }
               return peaks;
           }


           function visualizeData(processedData) {
               const data = processedData.original;
               const filteredData = processedData.filtered;
               const peaks = processedData.peaks;
               const zeroCrossings = processedData.zeroCrossings;
              
               const traces = [];


               // Combined acceleration trace (Row 7)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['combined acceleration']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Combined Acceleration',
                   yaxis: 'y7',
                   xaxis: 'x7',
                   showlegend: true
               });


               // Push peaks markers (on Combined acceleration plot)
               const peakIndices = peaks;
               const peakValues = peakIndices.map(i => data[i]['combined acceleration']);
               traces.push({
                   x: peakIndices,
                   y: peakValues,
                   type: 'scatter',
                   mode: 'markers',
                   marker: { color: 'red', size: 10 },
                   name: 'Push Peaks',
                   yaxis: 'y7',
                   xaxis: 'x7',
                   showlegend: true
               });
              
               // Angle Y(°) trace (Row 6)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['Angle Y(°)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Angle Y(°)',
                   yaxis: 'y6',
                   xaxis: 'x6',
                   showlegend: true
               });


               // Zero crossing markers (on Angle Y(°) plot)
               const cornerEntranceCrossings = zeroCrossings.filter(c => c.type === 'corner_entrance');
               const cornerExitCrossings = zeroCrossings.filter(c => c.type === 'corner_exit');


               traces.push({
                   x: cornerEntranceCrossings.map(c => c.index),
                   y: cornerEntranceCrossings.map(c => data[c.index]['Angle Y(°)']),
                   type: 'scatter',
                   mode: 'markers',
                   marker: { color: 'green', size: 12, symbol: 'cross' },
                   name: 'Corner Entrance',
                   yaxis: 'y6',
                   xaxis: 'x6',
                   showlegend: true
               });


               traces.push({
                   x: cornerExitCrossings.map(c => c.index),
                   y: cornerExitCrossings.map(c => data[c.index]['Angle Y(°)']),
                   type: 'scatter',
                   mode: 'markers',
                   marker: { color: 'red', size: 12, symbol: 'x' },
                   name: 'Corner Exit',
                   yaxis: 'y6',
                   xaxis: 'x6',
                   showlegend: true
               });


               // Angle X(°) trace (Row 5)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['Angle X(°)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Angle X(°)',
                   yaxis: 'y5',
                   xaxis: 'x5',
                   showlegend: true
               });


               // Angular velocity Z(°/s) trace (Row 4)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['Angular velocity Z(°/s)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'Angular velocity Z(°/s)',
                   yaxis: 'y4',
                   xaxis: 'x4',
                   showlegend: true
               });


               // -y-axis (g) trace (Row 3)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => -d['Acceleration Y(g)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: '-y-axis (g)',
                   yaxis: 'y3',
                   xaxis: 'x3',
                   showlegend: true
               });
              
               // x-axis (g) trace (Row 2)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['Acceleration X(g)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'x-axis (g)',
                   yaxis: 'y2',
                   xaxis: 'x2',
                   showlegend: true
               });


               // z-axis (g) trace (Row 1)
               traces.push({
                   x: data.map((d, i) => i),
                   y: data.map(d => d['Acceleration Z(g)']),
                   type: 'scatter',
                   mode: 'lines',
                   name: 'z-axis (g)',
                   yaxis: 'y1',
                   xaxis: 'x1',
                   showlegend: true
               });
              
               // Create layout with subplots
               const layout = {
                   title: 'Sensor Data Visualization',
                   height: 1000,
                   grid: {
                       rows: 7,
                       columns: 1,
                       subplots: [['xy'], ['x2y2'], ['x3y3'], ['x4y4'], ['x5y5'], ['x6y6'], ['x7y7']],
                       roworder: 'bottom to top',
                       yaxes: ['y1', 'y2', 'y3', 'y4', 'y5', 'y6', 'y7'],
                       xaxes: ['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7']
                   },
                   showlegend: true,
                   yaxis: { title: 'z-axis (g)' },
                   yaxis2: { title: 'x-axis (g)' },
                   yaxis3: { title: '-y-axis (g)' },
                   yaxis4: { title: 'z-axis (Deg/s)' },
                   yaxis5: { title: 'Angle X(°)' },
                   yaxis6: { title: 'Angle Y(°)' },
                   yaxis7: { title: 'Combined Acceleration' },
                   xaxis1: { title: 'Data Index' }
               };


               Plotly.newPlot(visualizationArea, traces, layout);
           }
       });
   </script>


</body>
</html>